import { Component, Input, OnInit, AfterViewInit } from '@angular/core';
import { NGXLogger } from 'ngx-logger';
import { CloudStorageService } from 'src/app/services/cloud-storage/cloud-storage.service';
import { ErrorCode } from 'src/app/services/error-handler/error-code.enum';
import { ErrorHandlerService } from 'src/app/services/error-handler/error-handler.service';
import { FsCollectionName } from 'src/app/services/firestore-data/firestore-collection-name.enum';
import { FirestoreDataService } from 'src/app/services/firestore-data/firestore-data.service';
import {
  FsAbility,
  FsAbilityType,
  FsCharacter,
  FsCharacterType,
  FsGeographType,
  FsRegion,
  FsWeaponType,
} from 'src/app/services/firestore-data/firestore-document.interface';
import { SpinnerService } from '../../services/spinner/spinner.service';
import { UserAuthService } from '../../services/user-auth/user-auth.service';
import { HtmlElementUtil } from '../../utils/html-element-util/html-element-util.class';
import { sleep } from '../../utils/sleep/sleep.utility';
import { isMobileMode } from '../../utils/window-size/window-size.util';

enum TableCellType {
  h1,
  h2,
  data,
}

class TeamMember {
  id: string;

  data: FsCharacter;

  url: string = '';

  thumb: Blob = new Blob();

  owned: boolean = false;

  hidden: boolean = false;

  thumbLoaded: boolean = false;

  onBorder: boolean = false;

  isKaichiku: boolean = false;

  constructor(id: string) {
    this.id = id;
    this.data = new FsCharacter(id);
  }
}

@Component({
  selector: 'app-team-view',
  templateUrl: './team-view.component.html',
  styleUrls: ['./team-view.component.scss'],
})
export class TeamViewComponent implements OnInit, AfterViewInit {
  private readonly className = 'TeamViewComponent';

  private readonly tableInitializeTimeMax = 10000;

  @Input() iTeam = -1; // It will become available after ngOnInit().

  private viewInitialized = false; // Flag on ngAfterViewInit().

  private viewCreated = false;

  teamMembers: TeamMember[] = [];

  isAllHidden = false;

  //============================================================================
  // Public functions.
  //
  constructor(
    private logger: NGXLogger,
    private userAuth: UserAuthService,
    private firestore: FirestoreDataService,
    private storage: CloudStorageService,
    private spinner: SpinnerService,
    private errorHandler: ErrorHandlerService
  ) {
    const location = `new ${this.className}()`;
    this.logger.trace(location);
  }

  ngOnInit(): void {
    const location = `${this.className}().ngOnInit()`;

    this.logger.trace(location, { iTeam: this.iTeam });

    // Get team info when user signed in.
    this.userAuth.addEventListener('signIn', async () => {
      this.logger.debug('callback', { iTeam: this.iTeam });
      await this.makeTeamView();
    });
  }

  async ngAfterViewInit(): Promise<void> {
    const location = `${this.className}.ngAfterViewInit()`;
    this.logger.trace(location, { iTeam: this.iTeam });

    // Set view initialized flag.
    this.viewInitialized = true;

    // Create view.
    await this.makeTeamView();
  }

  async onTrashClick(id: string): Promise<void> {
    this.spinner.show();

    await this.removeTeamMember(id);

    this.updateOnBorderFlag();

    this.spinner.hide();
  }

  //============================================================================
  // Private methods.
  //
  //----------------------------------------------------------------------------
  // View constructor.
  //
  private async makeTeamView(): Promise<void> {
    const location = `${this.className}.makeTeamView()`;
    this.logger.trace(location, { iTeam: this.iTeam });

    if (!this.makeTeamViewPrecond()) {
      return;
    }

    try {
      // Collect team member information.
      this.importTeam();

      // Exit if the team if empty.
      if (this.teamMembers.length === 0) {
        return;
      }

      // Wait initializing HTML elements.
      // <table> tags will be generated by importTeam() method.
      await this.waitTableTagReady(this.tableInitializeTimeMax);

      // Make character data table.
      this.makeCharacterInfoTables();

      // Load character thumbnail images.
      await this.loadThumbImages();

      // Update image elements.
      this.drawThumbImages();

      // Drag and drop behavior.
      this.setDragAndDropBehavior();

      // Update border flag.
      this.updateOnBorderFlag();

      // Set view-initalized flag.
      this.viewCreated = true;
    } catch (e) {
      this.errorHandler.notifyError(e);
    }
  }

  private makeTeamViewPrecond(): boolean {
    const location = `${this.className}.makeTeamViewPrecond()`;

    // This function shall be done after view init.
    if (!this.viewInitialized) {
      this.logger.warn(location, 'Do nothing as HTML view is not initialized.');
      return false;
    }

    // This function is allowed execution only once.
    if (this.viewCreated) {
      this.logger.warn(location, 'Do nothing as already created.');
      return false;
    }

    // User login is needed.
    if (!this.userAuth.signedIn) {
      this.logger.warn(location, 'User is not signed in.');
      return false;
    }

    return true;
  }

  private async waitTableTagReady(timeout: number): Promise<boolean> {
    const location = `${this.className}.waitTableTagReady()`;
    // this.logger.trace(location, { iTeam: this.iTeam });

    const sleepTime = 20;
    let waitTime = 0;
    let result = false;

    for (let i = 0; i < this.teamMembers.length; ++i) {
      result = false;
      const member = this.teamMembers[i];
      const tableId = `Team_${this.iTeam}_Member_Table_${member.id}`;

      while (waitTime < timeout) {
        const table = document.getElementById(tableId);
        if (!table) {
          // Sleep.
          await sleep(sleepTime);
          waitTime += sleepTime;
        } else {
          result = true;
          break;
        }
      }
    }

    if (result) {
      this.logger.info(location, 'HTML table tag has been generated.', { iTeam: this.iTeam, waitTime: waitTime });
    } else {
      this.logger.error(location, 'HTML table generation failed.', { iTeam: this.iTeam });
    }

    return result;
  }

  //----------------------------------------------------------------------------
  // Team array control.
  //
  private getTeamMemberIds(): string[] {
    const location = `${this.className}.getTeamMemberIds()`;

    if (this.iTeam === 0) {
      return this.userAuth.userData.team0;
    } else if (this.iTeam === 1) {
      return this.userAuth.userData.team1;
    } else if (this.iTeam === 2) {
      return this.userAuth.userData.team2;
    } else {
      const error = new Error(`${location} Invalid team index.`);
      error.name = ErrorCode.Unexpected;
      throw error;
    }
  }

  private importTeam() {
    const memberIds = this.getTeamMemberIds();

    // Clear existing data.
    this.teamMembers = [];

    for (let i = 0; i < memberIds.length; ++i) {
      // Get character data.
      const member = new TeamMember(memberIds[i]);
      member.data = this.firestore.getDataById(FsCollectionName.Characters, member.id) as FsCharacter;

      // Get character ownership status.
      member.owned = this.userAuth.userData.characters.includes(member.id);

      // Get kaichiku status.
      member.isKaichiku = this.userAuth.userData.kaichikuCharacters.includes(member.id);

      /**
       * It doesn't load image data here. Because image data loading may take time.
       * Image data loading shall be done afterwards.
       */

      // Add member info to the list.
      this.teamMembers.push(member);
    }
  }

  private async updateTeamMemberIds(memberIds: string[]): Promise<void> {
    let fieldName = '';
    let fieldValue = [];

    if (this.iTeam === 0) {
      this.userAuth.userData.team0 = memberIds;
      fieldName = 'team0';
      fieldValue = this.userAuth.userData.team0;
    } else if (this.iTeam === 1) {
      this.userAuth.userData.team1 = memberIds;
      fieldName = 'team1';
      fieldValue = this.userAuth.userData.team1;
    } else {
      this.userAuth.userData.team2 = memberIds;
      fieldName = 'team2';
      fieldValue = this.userAuth.userData.team2;
    }

    await this.firestore.updateField(FsCollectionName.Users, this.userAuth.userData.id, fieldName, fieldValue);
  }

  private async removeTeamMember(id: string): Promise<void> {
    const location = `${this.className}.removeTeamMember()`;

    // Find the member and hide him.
    const index = this.teamMembers.findIndex((item) => item.id === id);
    if (index >= 0) {
      this.teamMembers[index].hidden = true;
    } else {
      this.logger.warn(location, 'Invalid character ID.', { id: id });
      return;
    }

    // Get member ID array from user data.
    // And remove the ID from member IDs.
    const filteredMemberIds = this.getTeamMemberIds().filter((item) => item !== id);

    // Update user data.
    await this.updateTeamMemberIds(filteredMemberIds);

    // Check all members are hidden or not.
    this.isAllHidden = true;
    for (let i = 0; i < this.teamMembers.length; ++i) {
      if (!this.teamMembers[i].hidden) {
        this.isAllHidden = false;
        break;
      }
    }

    return;
  }

  /**
   * It changes order of the team member array.
   * And it also updates the user data.
   * @param changeId Character ID of the moved character.
   * @param beforeId Character ID. The 'changeId' character will be moved to before of this character.
   * @returns None
   */
  private async changeTeamMemerOrder(changeId: string, beforeId: string): Promise<void> {
    const location = `${this.className}.changeTeamMemerOrder()`;
    this.logger.trace(location, { changedId: changeId, beforeId: beforeId });

    // Get user team and check if the input character IDs are valid.
    const team = this.getTeamMemberIds();
    if (!team.includes(changeId)) {
      const error = new Error(`${location} The character ID is not found. changedId: ${changeId}`);
      error.name = ErrorCode.Unexpected;
      throw error;
    }
    if (beforeId !== '') {
      if (!team.includes(beforeId)) {
        const error = new Error(`${location} The character ID is not found. beforeId: ${beforeId}`);
        error.name = ErrorCode.Unexpected;
        throw error;
      }
    }

    // If changeId is same as beforeId, do nothig.
    if (changeId === beforeId) {
      this.logger.info(location, 'Do nothing as same IDs are input.');
      return;
    }

    // Remove 'changeId'.
    let changedTeam = team.filter((item) => item !== changeId);

    // Insert 'changeId' before 'beforeId'.
    let index = team.length;
    if (beforeId !== '') {
      index = changedTeam.findIndex((item) => item === beforeId);
    }
    changedTeam.splice(index, 0, changeId);

    // Logging.
    this.logger.debug(location, { team: team, changedTeam: changedTeam });

    // Update user data.
    await this.updateTeamMemberIds(changedTeam);

    return;
  }

  private updateOnBorderFlag() {
    const team = this.getTeamMemberIds();
    let threshold = 8;

    for (let i = 0; i < team.length; ++i) {
      const member = this.teamMembers.find((item) => item.id === team[i]);
      if (member) {
        if (member.hidden) {
          threshold++;
        } else {
          if (i === threshold) {
            member.onBorder = true;
          } else {
            member.onBorder = false;
          }
        }
      }
    }
  }

  //----------------------------------------------------------------------------
  // Thumbnail image control.
  //
  private async loadThumbImages(): Promise<number> {
    const location = `${this.className}.loadThumbImages()`;

    let thumbCount = 0;

    // Load thumbnail images.
    for (let i = 0; i < this.teamMembers.length; ++i) {
      const member = this.teamMembers[i];

      // Skip process if the thumbnail image has already been loaded.
      if (member.thumbLoaded) {
        continue;
      }

      // Make storage path and load image.
      const path = this.storage.makeCharacterThumbnailPath(member.data.index);
      const blob = await this.storage.get(path);
      thumbCount++;

      // Store image property data.
      member.url = window.URL.createObjectURL(blob);
      member.thumb = blob;
      member.thumbLoaded = true;
    }

    this.logger.info(location, 'Thumbnail images are loaded.', { count: thumbCount });

    return thumbCount;
  }

  private drawThumbImages() {
    const location = `${this.className}.drawThumbImages()`;

    // Process for each image element.
    for (let i = 0; i < this.teamMembers.length; ++i) {
      const member = this.teamMembers[i];

      // Skip process if the member is hidden or not loaded.
      if (member.hidden || !member.thumbLoaded) {
        continue;
      }

      // Get image element.
      const img = document.getElementById(`Team_${this.iTeam}_Member_Thumb_${member.id}`) as HTMLImageElement;
      if (!img) {
        const error = new Error(`${location} HTML image element is not available.`);
        error.name = ErrorCode.Unexpected;
        throw error;
      }

      // Set image source URL to the HTML image element.
      img.src = member.url;
    }

    return;
  }

  //----------------------------------------------------------------------------
  // Character info table.
  //
  private makeCharacterInfoTables() {
    const location = `${this.className}.makeCharacterInfoTables()`;
    this.logger.debug(location, { iTeam: this.iTeam });

    // Make table for each characters.
    for (let i = 0; i < this.teamMembers.length; ++i) {
      const tableId = `Team_${this.iTeam}_Member_Table_${this.teamMembers[i].id}`;

      // Make character table for 'a' character.
      this.makeCharacterInfoTable(tableId, this.teamMembers[i].data, this.teamMembers[i].isKaichiku);
    }
  }

  private makeCharacterInfoTable(tableId: string, character: FsCharacter, isKaichiku: boolean) {
    const location = `${this.className}.makeCharacterInfoTable()`;
    this.logger.debug(location, { iTeam: this.iTeam, tableId: tableId });

    const abilityTypes = this.firestore.getData(FsCollectionName.AbilityTypes) as FsAbilityType[];

    // Clear table.
    this.clearTable(tableId);

    // Get tbody element.
    const t = document.getElementById(tableId) as HTMLTableElement;

    // 1st row: Character name.
    let tr = t.insertRow();
    let td = tr.insertCell();
    td.textContent = `${character.name} (★${character.rarerity})`;
    td.colSpan = 2;
    this.setTdStyle(td, TableCellType.h1);

    // 2nd row: Basic information.
    tr = t.insertRow();
    td = tr.insertCell();
    td.textContent = '基本情報';
    this.setTdStyle(td);
    td = tr.insertCell();
    this.makeBasicInfoCellValue(td, character);
    this.setTdStyle(td);

    // Make ability info rows.
    for (let i = 0; i < abilityTypes.length; ++i) {
      this.makeAbilityInfoRows(t, character, abilityTypes[i], isKaichiku);
    }
  }

  private clearTable(tableId: string) {
    const t = document.getElementById(tableId) as HTMLTableElement;

    while (t.rows && t.rows.length > 0) {
      t.deleteRow(0);
    }
  }

  private setTdStyle(td: HTMLTableCellElement, type: TableCellType = TableCellType.data) {
    td.style.border = 'solid';
    td.style.borderWidth = 'thin';
    td.style.borderColor = 'var(--primary-color)';

    if (type === TableCellType.h1) {
      td.style.textAlign = 'center';
      td.style.backgroundColor = 'azure';
    }
  }

  private makeBasicInfoCellValue(td: HTMLTableCellElement, character: FsCharacter) {
    let result = '';

    // Get character type.
    const characterType = this.firestore.getDataById(FsCollectionName.CharacterTypes, character.type) as FsCharacterType;

    // Weapon type.
    if (character.weaponType !== '') {
      let tmp = '武器タイプ: ';
      let wt = this.firestore.getDataById(FsCollectionName.WeaponTypes, character.weaponType) as FsWeaponType;
      tmp += wt ? wt.name : 'n.a.';
      result += tmp;
    }

    // Geograph types.
    if (character.geographTypes.length > 0) {
      let tmp = ', 地形タイプ: ';
      for (let i = 0; i < character.geographTypes.length; ++i) {
        let gt = this.firestore.getDataById(FsCollectionName.GeographTypes, character.geographTypes[i]) as FsGeographType;
        if (i > 0) {
          tmp += '/';
        }
        tmp += gt ? gt.name : 'n.a.';
      }
      result += tmp;
    }

    // Region
    if (character.region !== '') {
      let tmp = ', 地域: ';
      let rg = this.firestore.getDataById(FsCollectionName.Regions, character.region) as FsRegion;
      tmp += rg ? rg.name : 'n.a.';
      result += tmp;
    }

    // Cost.
    if (character.cost > 0) {
      let tmp = `, コスト: ${character.cost}`;
      if (characterType?.isKaichikuEnable) {
        tmp += `/${character.costKai}(改)`;
      }
      result += tmp;
    }

    // Make normal text node.
    HtmlElementUtil.appendTextNode(td, result);
  }

  private makeAbilityInfoRows(t: HTMLTableElement, character: FsCharacter, type: FsAbilityType, isKaichiku: boolean) {
    // Filter abilities and abilities(kai).
    const abilityIds = !isKaichiku ? character.abilities : character.abilitiesKai;
    const abilities = (this.firestore.getDataByIds(FsCollectionName.Abilities, abilityIds) as FsAbility[]).filter((item) => item.type === type.id);

    // 2022-10-09: Show abilities by order in character ability list.
    // // Sort ability list by updated date.
    // this.firestore.sortByTimestamp(abilities, 'updatedAt');
    // this.firestore.sortByTimestamp(abilitiesKai, 'updatedAt');

    // CASE: No abilities. --> Do nothing.
    if (abilities.length === 0) {
      return;
    }

    // Make ability type caption.
    let tr = t.insertRow();
    let td = tr.insertCell();
    td.textContent = type.name;
    td.colSpan = 2;
    this.setTdStyle(td, TableCellType.h1);

    // Make ability name and description.
    let prevAbilityName = '';
    let prevAbilityDescCell: HTMLTableCellElement | undefined;
    for (let i = 0; i < abilities.length; ++i) {
      const ability = abilities[i];

      // Make ability name text.
      tr = t.insertRow();
      td = tr.insertCell();
      td.textContent = (!isKaichiku ? '[無印] ' : '[改壱] ') + ability.name;
      this.setTdStyle(td);

      // If previous ability is same, it expands row span.
      if (ability.name === prevAbilityName) {
        if (prevAbilityDescCell) {
          prevAbilityDescCell.rowSpan = 2;
        }
      }

      // Make ability description text.
      else {
        td = tr.insertCell();
        let descText = this.makeAbilityDescriptionText(ability.descriptions);

        // If the ability type is Keiryaku, add interval, cost, and token info.
        if (type.isKeiryaku && ability.interval >= 0) {
          descText += '\n' + this.makeKeiryakuPropertiesText(ability);
        }

        td.innerText = descText; // User 'innerText' property to activate line feed.
        this.setTdStyle(td);
      }

      // Update prev*** variables.
      prevAbilityName = ability.name;
      prevAbilityDescCell = td;
    }
  }

  private makeAbilityDescriptionText(descriptions: string[]): string {
    let result = '';

    // CASE: Mobile mode.
    // When text length > 18 full characters, no line feed is added.
    if (isMobileMode()) {
      result = descriptions[0];
      let prevLine = descriptions[0];
      for (let i = 1; i < descriptions.length; ++i) {
        if (this.getTextLengthUtf8(prevLine) <= 18 * 2) {
          result += '\n';
        }
        result += descriptions[i];
        prevLine = descriptions[i];
      }
    }

    // CASE: PC mode.
    // Connect all lines with line feeds.
    else {
      result = descriptions[0];
      for (let i = 1; i < descriptions.length; ++i) {
        result += '\n' + descriptions[i];
      }
    }

    return result;
  }

  /**
   * It calculate text length.
   * It counts a half character as 1, and counts a full character as 2.
   * @param text Input text.
   * @returns Text length.
   */
  private getTextLengthUtf8(text: string): number {
    let count = 0;
    let c = 0;

    for (let i = 0, len = text.length; i < len; i++) {
      c = text.charCodeAt(i);
      if ((c >= 0x0 && c < 0x81) || c == 0xf8f0 || (c >= 0xff61 && c < 0xffa0) || (c >= 0xf8f1 && c < 0xf8f4)) {
        count += 1;
      } else {
        count += 2;
      }
    }

    return count;
  }

  private makeKeiryakuPropertiesText(ability: FsAbility): string {
    let result = '';

    if (ability.tokenLayouts.length === 0) {
      result += `(CT:${ability.interval}秒 / 消費気:${ability.cost})`;
    } else {
      let tokenLayoutText = '';
      this.firestore.sortMapCellTypes(ability.tokenLayouts);
      for (let j = 0; j < ability.tokenLayouts.length; ++j) {
        if (j > 0) {
          tokenLayoutText += ',';
        }
        tokenLayoutText += ability.tokenLayouts[j];
      }
      result += `(CT:${ability.interval}秒 / 消費気:${ability.cost} / 配置:${tokenLayoutText})`;
    }

    return result;
  }

  //----------------------------------------------------------------------------
  // Drag and drop control.
  //
  private setDragAndDropBehavior() {
    const location = `${this.className}.setDragAndDropBehavior()`;
    this.logger.trace(location);

    for (let i = 0; i < this.teamMembers.length; ++i) {
      const member = this.teamMembers[i];
      // Get list element.
      const elemId = `Team_${this.iTeam}_Member_${member.id}`;
      this.setDragAndDropBehaviorToElementById(elemId);
    }

    this.setDragAndDropBehaviorToElementById('dummy-member-element');
  }

  private setDragAndDropBehaviorToElementById(elemId: string) {
    const li = document.getElementById(elemId);
    if (!li) {
      const error = new Error(`${location} List element was not found. { id: ${elemId} }`);
      error.name = ErrorCode.Unexpected;
      throw error;
    }

    // Set drag and drop behaviour.
    // Start: When a list item is dragged.
    li.ondragstart = (event: DragEvent) => {
      this.logger.debug('ondragstart', { index: li.id });
      if (event.dataTransfer) {
        event.dataTransfer.setData('text/plain', li.id);
      }
    };
    // Over: WHen a dragged item move over other list item.
    // !!! The focused item is the covered list item. (not the dragged list item.) !!!
    li.ondragover = (event) => {
      event.preventDefault();
      li.style.borderTop = '2px solid blue';
    };
    // Leave: When a dragged item go out of the other list item.
    // !!! The focused item is the covered list item. (Not the dragged list item.) !!!
    li.ondragleave = () => {
      li.style.borderTop = '';
    };
    // Drop: When a dragged list item is dropped.
    // !!! The focused item is the item which is located at the dropped position. (Not the dropped item.) !!!
    li.ondrop = (event) => {
      event.preventDefault();
      li.style.borderTop = '';
      if (event.dataTransfer) {
        // Get dragged element from dataTransfer.
        const draggedElemId = event.dataTransfer.getData('text/plain');
        this.logger.debug('ondrop', { draggedElem: draggedElemId, droppedElem: li.id });

        // Lock screen.
        this.spinner.show();

        // Move list item.
        this.moveListItemBeforeAnotherItem(draggedElemId, li.id);

        // Update user team info.
        const draggedCharacterId = draggedElemId.replace(`Team_${this.iTeam}_Member_`, '');
        const droppedCharacterId = li.id.replace(`Team_${this.iTeam}_Member_`, '');
        this.changeTeamMemerOrder(draggedCharacterId, droppedCharacterId);
        this.updateOnBorderFlag();

        // Unlock screen.
        this.spinner.hide();
      }
    };
  }

  private moveListItemBeforeAnotherItem(movedItemId: string, destItemId: string) {
    const movedItem = document.getElementById(movedItemId) as HTMLLIElement;
    const destItem = document.getElementById(destItemId) as HTMLLinkElement;

    if (!movedItem || !destItem || !destItem.parentNode) {
      return;
    }

    destItem.parentNode.insertBefore(movedItem, destItem);
  }
}
